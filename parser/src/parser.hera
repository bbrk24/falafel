Statements
  _* (Statement _*)* ->
    return $2.map(el => el[0])

Identifier
  /(?<!\w|\d)\w[\w\d]*/

_
  /\s+/
  Comment

Comment
  "//" /[^\n]*/
  "/*" /(?:[^*]|\*[^\/])*/ "*/"

EOS
  Comment* /[\n;]/
  _* /(?=\})/
  !. # EOF

Statement
  Declaration
  Expression EOS -> $1

Declaration
  ClassDefinition
  VarDeclaration

InheritanceClause
  ":" _* Type -> $3

ClassBody
  "{" _* (Declaration _*)* "}" ->
    return $3.map(el => el[0])

ClassDefinition
  "final"?:final _+ "class" _+ Identifier:name _* InheritanceClause?:base _* ClassBody:body ->
    return { type: 'ClassDefinition', name, base, body, final: final != null }

Type
  Identifier ->
    return { name: $1, arguments: [] }
  Identifier "<" _* Type:arg0 (_* "," _* Type)*:args _* ","? _* ">" ->
    const arguments_ = [
      arg0,
      ...args.map(el => el[3])
    ];
    return { name: $1, arguments: arguments_ };

TypeClause
  ":" _* Type -> $3

VarDeclaration
  "var" _+ Identifier:name _* TypeClause:declaredType _* "=" _* Expression:value EOS ->
    return { type: 'VarDeclaration', name, declaredType, value }

# BaseExpression is any expression that is not a BinaryExpression. BinaryExpression is then built
# in several layers on top of BaseExpression so as to establish a precedence hierarchy.
BaseExpression
  # Some notes on ordering:
  # - FunctionCall must come before Identifier
  # - BooleanLiteral must come before Identifier
  # - I think FunctionCall must come before paren handling but I haven't proven it
  FunctionCall
  BooleanLiteral
  StringInterpolation
  NumberLiteral
  StringLiteral
  "(" Expression ")" -> $2
  Identifier ->
    return { type: 'Identifier', name: $1 }
  PrefixExpression

BooleanLiteral
  /(?<!\w|\d)(?:true|false)(?!\w|\d)/ ->
    return { type: 'BooleanLiteral', value: $0 === 'true' }

PrefixExpression
  ("!" / "-") BaseExpression ->
    return { type: "PrefixExpression", operator: $1, operand: $2 }

FunctionCall
  Identifier "(" _* ")" ->
    return { type: 'FunctionCall', function: $1, arguments: [] }
  Identifier "(" _* Expression:arg0 (_* "," _* Expression)*:args _* ","? _* ")" ->
    const arguments_ = [
      arg0,
      ...args.map(el => el[3])
    ];
    return { type: 'FunctionCall', function: $1, arguments: arguments_ };

NumberLiteral
  "-"? "0x" /[0-9a-fA-F]+/ ->
    const stringValue = $0.join('');
    const value = BigInt(stringValue);
    if (value < -(1n << 31n) || value >= (1n << 31n)) {
      console.warn(`Integer literal ${stringValue} may be too big to represent on some systems.`);
    } else if (value < -(1n << 63n) || value >= (1n << 63n)) {
      throw new RangeError(`Integer literal ${stringValue} is too big!`);
    }
    return { type: 'IntegerLiteral', value }

  /-?(\d+\.\d+)(?:[eE]([+\-]\d+))?/ ->
    const value = Number($0);
    if (!Number.isFinite(value)) {
      throw new RangeError(`${$0} is not representable as a Double.`);
    }
    if (value === 0.0 && Number($1) != 0.0 && Number($2) < 0) {
      console.warn(`${$0} is too small and will be rounded to zero.`);
    }
    return { type: 'DecimalLiteral', value: Number($0) }

  /-?\d+/ ->
    const value = BigInt($0);
    if (value < -(1n << 31n) || value >= (1n << 31n)) {
      console.warn(`Integer literal ${$0} may be too big to represent on some systems.`);
    } else if (value < -(1n << 63n) || value >= (1n << 63n)) {
      throw new RangeError(`Integer literal ${$0} is too big!`);
    }
    return { type: 'IntegerLiteral', value }

StringInterpolation
  "`" InterpolationPiece* "`" ->
    return { type: 'StringInterpolation', pieces: $2 }

InterpolationPiece
  "${" Expression "}" -> $2
  /(?:[^\\`\n\$]|\\(?:[\\"`nrt\$]|u[0-9a-fA-F]{4}))*/ ->
    return { type: 'StringLiteral', value: JSON.parse(`"${$0.replaceAll('\\$', '$').replaceAll('\\`', '`')}"`) }

StringLiteral
  /"(?:[^\\"\n]|\\(?:[\\"`nrt\$]|u[0-9a-fA-F]{4}))*"/ ->
    return { type: 'StringLiteral', value: JSON.parse($0.replaceAll('\\$', '$').replaceAll('\\`', '`')) }

PowExpression
  (BaseExpression _* "**" _*)*:head BaseExpression:tail ->
    return head.reduceRight((acc, curr) => {
      return { type: 'BinaryExpression', lhs: curr[0], operator: "**", rhs: acc }
    }, tail)

MulExpression
  PowExpression:first (_* ("*" / "/") _* PowExpression)*:rest ->
    return rest.reduce((acc, curr) => {
      return { type: 'BinaryExpression', lhs: acc, operator: curr[1], rhs: curr[3] }
    }, first)

AddExpression
  MulExpression:first (_* ("+" / "-") _* MulExpression)*:rest ->
    return rest.reduce((acc, curr) => {
      return { type: 'BinaryExpression', lhs: acc, operator: curr[1], rhs: curr[3] }
    }, first)

ComparisonExpression
  AddExpression:first (_* (">" / ">=" / "<" / "<=" / "==" / "!=") _* AddExpression)*:rest ->
    return rest.reduce((acc, curr) => {
      return { type: 'BinaryExpression', lhs: acc, operator: curr[1], rhs: curr[3] }
    }, first)

AndExpression
  ComparisonExpression:first (_* "&&" _* ComparisonExpression)*:rest ->
    return rest.reduce((acc, curr) => {
      return { type: 'BinaryExpression', lhs: acc, operator: curr[1], rhs: curr[3] }
    }, first)

Expression
  AndExpression:first (_* "||" _* AndExpression)*:rest ->
    return rest.reduce((acc, curr) => {
      return { type: 'BinaryExpression', lhs: acc, operator: curr[1], rhs: curr[3] }
    }, first)
