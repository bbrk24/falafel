Statements
  _* (Statement _*)* ->
    return $2.map(el => el[0])

Identifier
  /(?<!\w|\d)\w[\w\d]*/

_
  /\s+/
  Comment

Comment
  "//" /[^\n]*/
  "/*" /(?:[^*]|\*[^\/])*/ "*/"

EOS
  Comment* /[\n;]/
  _* /(?=\})/
  !. # EOF

Statement
  Declaration
  Assignment EOS -> $1
  Expression EOS -> $1
  ConditionalStatement
  LoopStatement

ConditionalStatement
  /(?<!\w|\d)if/ _* "(" _* Expression:cond _* ")" _* "{" Statements:body "}" _* ElseClause?:alt ->
    return { type: 'ConditionalStatement', condition: cond, trueBlock: body, falseBlock: alt };

ElseClause
  "else" _* "{" Statements "}" -> $4
  "else" _+ ConditionalStatement ->
    return [$3]

LoopStatement
  /(?<!\w|\d)while/ _* "(" _* Expression:cond _* ")" _* "{" Statements:body "}" ->
    return { type: 'LoopStatement', condition: cond, body }

Assignment
  Identifier _* "=" _* Expression ->
    return { type: 'Assignment', name: $1, value: $5 }
  Identifier:name _* ("+" / "-" / "*" / "/" / "%" / "&&" / "||"):operator "=" _* Expression:rhs ->
    const value = { type: 'BinaryExpression', lhs: { type: 'Identifier', name }, rhs, operator };
    return { type: 'Assignment', name, value };

Declaration
  ClassDefinition
  VarDeclaration

InheritanceClause
  ":" _* Type -> $3

ClassBody
  "{" _* (Declaration _*)* "}" ->
    return $3.map(el => el[0])

ClassDefinition
  "final"?:final _+ "class" _+ Identifier:name _* InheritanceClause?:base _* ClassBody:body ->
    return { type: 'ClassDefinition', name, base, body, final: final != null }

Type
  Identifier "<" _* Type:arg0 (_* "," _* Type)*:args _* ","? _* ">" ->
    const arguments_ = [
      arg0,
      ...args.map(el => el[3])
    ];
    return { name: $1, arguments: arguments_ };
  Identifier ->
    return { name: $1, arguments: [] }
  "(" _* Type _* ")" -> $3

TypeClause
  ":" _* Type -> $3

VarDeclaration
  "var" _+ Identifier:name _* TypeClause:declaredType _* "=" _* Expression:value EOS ->
    return { type: 'VarDeclaration', name, declaredType, value }

# BaseExpression is any expression that is not a BinaryExpression or MemberAccessExpression.
# BinaryExpression is then built in several layers on top of BaseExpression so as to establish
# a precedence hierarchy.
BaseExpression
  # Some notes on ordering:
  # - FunctionCall must come before Identifier
  # - BooleanLiteral must come before Identifier
  # - I think FunctionCall must come before paren handling but I haven't proven it
  FunctionCall
  BooleanLiteral
  StringInterpolation
  NumberLiteral
  StringLiteral
  "(" _* Expression _* ")" -> $3
  Identifier ->
    return { type: 'Identifier', name: $1 }
  PrefixExpression
  ArrayLiteral

BooleanLiteral
  /(?<!\w|\d)(?:true|false)(?!\w|\d)/ ->
    return { type: 'BooleanLiteral', value: $0 === 'true' }

PrefixExpression
  ("!" / "-") BaseExpression ->
    return { type: "PrefixExpression", operator: $1, operand: $2 }

FunctionCall
  Identifier "(" _* ")" ->
    return { type: 'FunctionCall', function: $1, arguments: [] }
  Identifier "(" _* Expression:arg0 (_* "," _* Expression)*:args _* ","? _* ")" ->
    const arguments_ = [
      arg0,
      ...args.map(el => el[3])
    ];
    return { type: 'FunctionCall', function: $1, arguments: arguments_ };

NumberLiteral
  "-"? "0x" /[0-9a-fA-F]+/ ->
    const stringValue = $0.join('');
    const value = BigInt(stringValue);
    if (value < -(1n << 31n) || value >= (1n << 31n)) {
      console.warn(`Integer literal ${stringValue} may be too big to represent on some systems.`);
    } else if (value < -(1n << 63n) || value >= (1n << 63n)) {
      throw new RangeError(`Integer literal ${stringValue} is too big!`);
    }
    return { type: 'IntegerLiteral', value }

  /-?(\d+\.\d+)(?:[eE]([+\-]\d+))?/ ->
    const value = Number($0);
    if (!Number.isFinite(value)) {
      throw new RangeError(`${$0} is not representable as a Double.`);
    }
    if (value === 0.0 && Number($1) != 0.0 && Number($2) < 0) {
      console.warn(`${$0} is too small and will be rounded to zero.`);
    }
    return { type: 'DecimalLiteral', value: Number($0) }

  /-?\d+/ ->
    const value = BigInt($0);
    if (value < -(1n << 31n) || value >= (1n << 31n)) {
      console.warn(`Integer literal ${$0} may be too big to represent on some systems.`);
    } else if (value < -(1n << 63n) || value >= (1n << 63n)) {
      throw new RangeError(`Integer literal ${$0} is too big!`);
    }
    return { type: 'IntegerLiteral', value }

StringInterpolation
  "`" InterpolationPiece* "`" ->
    return { type: 'StringInterpolation', pieces: $2 }

InterpolationPiece
  "${" Expression "}" -> $2
  /(?:[^\\`\n\$]|\\(?:[\\"`nrt\$]|u[0-9a-fA-F]{4}))*/ ->
    return { type: 'StringLiteral', value: JSON.parse(`"${$0.replaceAll('\\$', '$').replaceAll('\\`', '`')}"`) }

StringLiteral
  /"(?:[^\\"\n]|\\(?:[\\"`nrt\$]|u[0-9a-fA-F]{4}))*"/ ->
    return { type: 'StringLiteral', value: JSON.parse($0.replaceAll('\\$', '$').replaceAll('\\`', '`')) }

ArrayLiteral
  "[" (_* Expression _* "," _*)*:head (Expression _* ("," _*)?)?:tail "]" ->
    const values = [];
    if (head?.length) {
      values.push(...head.map(el => el[1]));
    }
    if (tail?.[0] != null) {
      values.push(tail[0]);
    }
    return { type: 'ArrayLiteral', values };

MemberAccessExpression
  BaseExpression:first (("." _* (FunctionCall / Identifier)) / (_* "[" _* Expression _* "]") / (_* "@" _* Type))*:rest ->
    return rest.reduce((acc, curr) => {
      if (curr[0] === '.') {
        return { type: 'MemberAccessExpression', base: acc, member: curr[2] };
      } else if (curr[1] === '@') {
        return { type: 'CastExpression', value: acc, declaredType: curr[3] };
      } else {
        return { type: 'IndexExpression', base: acc, index: curr[3] }; 
      }
    }, first);

PowExpression
  (MemberAccessExpression _* "**" _*)*:head MemberAccessExpression:tail ->
    return head.reduceRight((acc, curr) => {
      return { type: 'BinaryExpression', lhs: curr[0], operator: "**", rhs: acc }
    }, tail)

MulExpression
  PowExpression:first (_* ("*" / "/" / "%") _* PowExpression)*:rest ->
    return rest.reduce((acc, curr) => {
      return { type: 'BinaryExpression', lhs: acc, operator: curr[1], rhs: curr[3] }
    }, first)

AddExpression
  MulExpression:first (_* ("+" / "-") _* MulExpression)*:rest ->
    return rest.reduce((acc, curr) => {
      return { type: 'BinaryExpression', lhs: acc, operator: curr[1], rhs: curr[3] }
    }, first)

ComparisonExpression
  AddExpression:first (_* (">=" / "<=" / "==" / "!=" / ">" / "<") _* AddExpression)*:rest ->
    return rest.reduce((acc, curr) => {
      return { type: 'BinaryExpression', lhs: acc, operator: curr[1], rhs: curr[3] }
    }, first)

AndExpression
  ComparisonExpression:first (_* "&&" _* ComparisonExpression)*:rest ->
    return rest.reduce((acc, curr) => {
      return { type: 'BinaryExpression', lhs: acc, operator: curr[1], rhs: curr[3] }
    }, first)

Expression
  AndExpression:first (_* "||" _* AndExpression)*:rest ->
    return rest.reduce((acc, curr) => {
      return { type: 'BinaryExpression', lhs: acc, operator: curr[1], rhs: curr[3] }
    }, first)
