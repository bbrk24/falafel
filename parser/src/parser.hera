Statements
  _* (Statement _*)* ->
    return $2.map(el => el[0])

Identifier
  /(?<!\w|\d)\w[\w\d]*/

_
  /\s+/
  Comment

Comment
  "//" /[^\n]*/
  "/*" /(?:[^*]|\*[^\/])*/ "*/"

EOS
  Comment* /[\n;]/
  _* /(?=\})/
  !. # EOF

Statement
  Declaration
  Assignment EOS -> $1
  Expression EOS -> $1
  ConditionalStatement
  LoopStatement

ConditionalStatement
  /(?<!\w|\d)if/ _* "(" _* Expression:cond _* ")" _* "{" Statements:body "}" _* ElseClause?:alt ->
    return { type: 'ConditionalStatement', condition: cond, trueBlock: body, falseBlock: alt, loc: $loc };

ElseClause
  "else" _* "{" Statements "}" -> $4
  "else" _+ ConditionalStatement ->
    return [$3]

LoopStatement
  /(?<!\w|\d)while/ _* "(" _* Expression:cond _* ")" _* "{" Statements:body "}" ->
    return { type: 'LoopStatement', condition: cond, body, loc: $loc }

Assignment
  MemberAccessExpression _* "=" _* Expression ->
    return { type: 'Assignment', lhs: $1, rhs: $5, loc: $loc }
  MemberAccessExpression:lhs _* ("+" / "-" / "*" / "/" / "%" / "&&" / "||"):operator "=" _* Expression:rhs ->
    return { type: 'Assignment', lhs, rhs: { type: 'BinaryExpression', lhs, rhs, operator, loc: $loc }, loc: $loc }

Declaration
  ClassDefinition
  VarDeclaration

InheritanceClause
  ":" _* Type -> $3

ClassBody
  "{" _* (Declaration _*)* "}" ->
    return $3.map(el => el[0])

ClassDefinition
  "final"?:final _+ "class" _+ Identifier:name _* InheritanceClause?:base _* ClassBody:body ->
    return { type: 'ClassDefinition', name, base, body, final: final != null, loc: $loc }

Type
  Identifier "<" _* Type:arg0 (_* "," _* Type)*:args _* ","? _* ">" ->
    const arguments_ = [
      arg0,
      ...args.map(el => el[3])
    ];
    return { name: $1, arguments: arguments_, loc: $loc };
  Identifier ->
    return { name: $1, arguments: [], loc: $loc }
  "(" _* Type _* ")" -> $3

TypeClause
  ":" _* Type -> $3

VarDeclaration
  "var" _+ Identifier:name _* TypeClause:declaredType _* "=" _* Expression:value EOS ->
    return { type: 'VarDeclaration', name, declaredType, value, loc: $loc }

# BaseExpression is any expression that is not a BinaryExpression or MemberAccessExpression.
# BinaryExpression is then built in several layers on top of BaseExpression so as to establish
# a precedence hierarchy.
BaseExpression
  # Some notes on ordering:
  # - FunctionCall must come before Identifier
  # - BooleanLiteral must come before Identifier
  # - I think FunctionCall must come before paren handling but I haven't proven it
  FunctionCall
  BooleanLiteral
  StringInterpolation
  NumberLiteral
  StringLiteral
  CharLiteral
  "(" _* Expression _* ")" -> $3
  Identifier ->
    return { type: 'Identifier', name: $1, loc: $loc }
  PrefixExpression
  ArrayLiteral

BooleanLiteral
  /(?<!\w|\d)(?:true|false)(?!\w|\d)/ ->
    return { type: 'BooleanLiteral', value: $0 === 'true', loc: $loc }

PrefixExpression
  ("!" / "-") BaseExpression ->
    return { type: "PrefixExpression", operator: $1, operand: $2, loc: $loc }

FunctionCall
  Identifier "(" _* ")" ->
    return { type: 'FunctionCall', function: $1, arguments: [], loc: $loc }
  Identifier "(" _* Expression:arg0 (_* "," _* Expression)*:args _* ","? _* ")" ->
    const arguments_ = [
      arg0,
      ...args.map(el => el[3])
    ];
    return { type: 'FunctionCall', function: $1, arguments: arguments_, loc: $loc };

NumberLiteral
  "-"? "0x" /[0-9a-fA-F]+/ ->
    const stringValue = $0.join('');
    const value = BigInt(stringValue);
    if (value < -(1n << 31n) || value >= (1n << 31n)) {
      console.warn(`Integer literal ${stringValue} may be too big to represent on some systems.`);
    } else if (value < -(1n << 63n) || value >= (1n << 63n)) {
      throw new RangeError(`Integer literal ${stringValue} is too big!`);
    }

    if (stringValue.startsWith('-') && value === 0n) {
      console.warn(`Integer literal ${stringValue} is equivalent to positive 0. Use '-0.0' for floating-point negative zero.`)
    }

    return { type: 'IntegerLiteral', value, loc: $loc }

  /-?(\d+\.\d+)(?:[eE]([+\-]\d+))?/ ->
    const value = Number($0);
    if (!Number.isFinite(value)) {
      throw new RangeError(`${$0} is not representable as a Double.`);
    }
    if (value === 0.0 && Number($1) != 0.0 && Number($2) < 0) {
      console.warn(`${$0} is too small and will be rounded to zero.`);
    }
    return { type: 'DecimalLiteral', value, loc: $loc }

  /-?\d+/ ->
    const value = BigInt($0);
    if (value < -(1n << 31n) || value >= (1n << 31n)) {
      console.warn(`Integer literal ${$0} may be too big to represent on some systems.`);
    } else if (value < -(1n << 63n) || value >= (1n << 63n)) {
      throw new RangeError(`Integer literal ${$0} is too big!`);
    }

    if ($0.startsWith('-') && value === 0n) {
      console.warn(`Integer literal ${$0} is equivalent to positive 0. Use '-0.0' for floating-point negative zero.`)
    }

    return { type: 'IntegerLiteral', value, loc: $loc }

StringInterpolation
  "`" InterpolationPiece* "`" ->
    return { type: 'StringInterpolation', pieces: $2, loc: $loc }

InterpolationPiece
  "${" Expression "}" -> $2
  /(?:[^\\`\n\$]|\\(?:[\\"`nrt\$']|u[0-9a-fA-F]{4}))*/ ->
    return { type: 'StringLiteral', value: JSON.parse(`"${$0.replaceAll(/\\(['`\$])/gu, $1)}"`), loc: $loc }

StringLiteral
  /"(?:[^\\"\n]|\\(?:[\\"`nrt\$']|u[0-9a-fA-F]{4}))*"/ ->
    return { type: 'StringLiteral', value: JSON.parse($0.replaceAll(/\\(['`\$])/gu, $1)), loc: $loc }

ArrayLiteral
  "[" (_* Expression _* "," _*)*:head (Expression _* ("," _*)?)?:tail "]" ->
    const values = [];
    if (head?.length) {
      values.push(...head.map(el => el[1]));
    }
    if (tail?.[0] != null) {
      values.push(tail[0]);
    }
    return { type: 'ArrayLiteral', values, loc: $loc };

CharLiteral
  "'" /[^\\'\n]|\\[\\"`nrt\$']/:char "'" ->
    let value = char[0];
    if (value[0] === '\\') {
      value = JSON.parse(`"${value.replaceAll(/\\(['`\$])/gu, $1)}"`);
    }
    if (value.charCodeAt(0) > 0x7f) {
      throw new SyntaxError(`'${value}' is more than one character`);
    }
    return { type: 'CharLiteral', value, loc: $loc };

MemberAccessExpression
  BaseExpression:first (("." _* (FunctionCall / Identifier)) / (_* "[" _* Expression _* "]") / (_* "@" _* Type))*:rest ->
    const result = rest.reduce((acc, curr) => {
      if (curr[0] === '.') {
        return { type: 'MemberAccessExpression', base: acc, member: curr[2] };
      } else if (curr[1] === '@') {
        return { type: 'CastExpression', value: acc, declaredType: curr[3] };
      } else {
        return { type: 'IndexExpression', base: acc, index: curr[3] }; 
      }
    }, first);
    result.loc ??= $loc;
    return result;

PowExpression
  (MemberAccessExpression _* "**" _*)*:head MemberAccessExpression:tail ->
    const result = head.reduceRight((acc, curr) => {
      return { type: 'BinaryExpression', lhs: curr[0], operator: "**", rhs: acc };
    }, tail);
    result.loc ??= $loc;
    return result;

MulExpression
  PowExpression:first (_* ("*" / "/" / "%") _* PowExpression)*:rest ->
    const result = rest.reduce((acc, curr) => {
      return { type: 'BinaryExpression', lhs: acc, operator: curr[1], rhs: curr[3] };
    }, first);
    result.loc ??= $loc;
    return result;

AddExpression
  MulExpression:first (_* ("+" / "-") _* MulExpression)*:rest ->
    const result = rest.reduce((acc, curr) => {
      return { type: 'BinaryExpression', lhs: acc, operator: curr[1], rhs: curr[3] };
    }, first);
    result.loc ??= $loc;
    return result;

ComparisonExpression
  AddExpression:first (_* (">=" / "<=" / "==" / "!=" / ">" / "<") _* AddExpression)*:rest ->
    const result = rest.reduce((acc, curr) => {
      return { type: 'BinaryExpression', lhs: acc, operator: curr[1], rhs: curr[3] };
    }, first);
    result.loc ??= $loc;
    return result;

AndExpression
  ComparisonExpression:first (_* "&&" _* ComparisonExpression)*:rest ->
    const result = rest.reduce((acc, curr) => {
      return { type: 'BinaryExpression', lhs: acc, operator: curr[1], rhs: curr[3] };
    }, first);
    result.loc ??= $loc;
    return result;

Expression
  AndExpression:first (_* "||" _* AndExpression)*:rest ->
    const result = rest.reduce((acc, curr) => {
      return { type: 'BinaryExpression', lhs: acc, operator: curr[1], rhs: curr[3] };
    }, first);
    result.loc ??= $loc;
    return result;
